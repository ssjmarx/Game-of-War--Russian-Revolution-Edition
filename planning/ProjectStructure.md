# **PROJECT STRUCTURE**

**Godot 4.x | Modular Architecture | Signal-Based Communication**

---

## **DIRECTORY STRUCTURE**

```
Game of War: Russian Revolution Edition/
├── .godot/                    # Generated by Godot (do not commit)
│
├── scenes/                    # All scene files (.tscn)
│   ├── game/                  # Core gameplay scenes
│   │   ├── game_board.tscn    # Main board game scene
│   │   ├── curtain.tscn       # "Pass device" transition
│   │   └── battle_scene.tscn  # Battle view overlay
│   │
│   ├── units/                 # Unit-specific scenes
│   │   ├── unit.tscn          # Base unit scene (instantiate for each unit)
│   │   └── unit_markers/      # Visual marker components
│   │       ├── infantry_marker.tscn
│   │       ├── cavalry_marker.tscn
│   │       ├── artillery_marker.tscn
│   │       ├── machine_gun_marker.tscn
│   │       ├── train_engine_marker.tscn
│   │       └── train_car_marker.tscn
│   │
│   ├── ui/                    # UI scenes
│   │   ├── main_menu.tscn
│   │   ├── level_select.tscn
│   │   ├── options.tscn
│   │   ├── narrative_screen.tscn
│   │   └── hud/               # In-game HUD components
│   │       ├── turn_indicator.tscn
│   │       ├── order_counter.tscn
│       ├── unit_info_panel.tscn
│   │       ├── order_list.tscn
│   │       └── special_actions.tscn
│   │
│   └── menus/                 # Overlay menus
│       ├── victory_screen.tscn
│       └── defeat_screen.tscn
│
├── scripts/                   # All script files (.gd)
│   ├── autoloads/             # Singletons (AutoLoad)
│   │   ├── game_manager.gd
│   │   ├── save_system.gd
│   │   ├── data_manager.gd
│   │   └── audio_controller.gd
│   │
│   ├── game/                  # Core game logic
│   │   ├── game_board.gd      # Main board controller
│   │   ├── turn_state_machine.gd
│   │   ├── order_manager.gd
│   │   ├── collision_system.gd
│   │   ├── battle_system.gd
│   │   ├── network_system.gd
│   │   └── railway_system.gd
│   │
│   ├── units/                 # Unit scripts
│   │   ├── unit.gd            # Base unit class
│   │   └── unit_behaviors/    # Unit-specific behavior scripts
│   │       ├── cavalry_behavior.gd
│   │       ├── train_behavior.gd
│   │       ├── heavy_unit_behavior.gd
│   │       └── relay_behavior.gd
│   │
│   ├── ui/                    # UI scripts
│   │   ├── main_menu.gd
│   │   ├── level_select.gd
│   │   ├── options.gd
│   │   ├── narrative_screen.gd
│   │   ├── hud/
│   │   │   ├── turn_indicator.gd
│   │   │   ├── order_counter.gd
│   │   │   ├── unit_info_panel.gd
│   │   │   ├── order_list.gd
│   │   │   └── special_actions.gd
│   │   └── menus/
│   │       ├── victory_screen.gd
│   │       └── defeat_screen.gd
│   │
│   └── utils/                 # Utility scripts
│       ├── math_helpers.gd
│       ├── pathfinding.gd
│       └── debug_visualizer.gd
│
├── resources/                 # Godot resource files (.tres)
│   ├── units/                 # Unit definitions
│   │   ├── infantry.tres
│   │   ├── cavalry.tres
│   │   ├── artillery.tres
│   │   ├── swift_artillery.tres
│   │   ├── relay.tres
│   │   ├── swift_relay.tres
│   │   ├── machine_gun_nest.tres
│   │   ├── observation_balloon.tres
│   │   ├── armored_tram.tres
│   │   ├── armored_train_engine.tres
│   │   ├── armored_train_gun_car.tres
│   │   ├── armored_train_troop_car.tres
│   │   ├── car.tres
│   │   └── armored_car.tres
│   │
│   ├── tiles/                 # Tile definitions
│   │   ├── tile_types.tres
│   │   ├── terrain_data.tres
│   │   └── infrastructure_data.tres
│   │
│   ├── maps/                  # Campaign maps
│   │   ├── map1_iron_horse.tres
│   │   ├── map2_red_petrograd.tres
│   │   └── map3_woods_bryansk.tres
│   │
│   └── themes/                # UI themes
│       └── main_theme.tres
│
├── assets/                    # External assets
│   ├── fonts/
│   │   └── default_font.ttf
│   │
│   ├── sounds/
│   │   ├── effects/
│   │   │   ├── move.wav
│   │   │   ├── attack.wav
│   │   │   ├── explosion.wav
│   │   │   └── victory.wav
│   │   └── music/
│   │       ├── main_menu.ogg
│   │       └── battle_theme.ogg
│   │
│   └── shaders/               # Custom shaders (if needed)
│
├── addons/                    # Third-party plugins (empty for now)
│
├── planning/                  # Planning documents
│   ├── rules.md
│   ├── Implementation.md
│   └── ProjectPlanningRoadmap.md
│
├── .gitignore
├── icon.svg
└── project.godot              # Godot project file
```

---

## **AUTOLOAD SINGLETONS**

These are registered in `project.godot` under `[autoload]` and are globally accessible.

### **GameManager**
**Purpose**: Central game state controller and scene manager.

**Responsibilities**:
- Scene transitions (menu → game → battle → menu)
- Turn management coordination
- Global game state (current level, player turn)
- Event emission for major game events

**Key Signals**:
```gdscript
signal scene_changed(new_scene: String)
signal turn_started(player_id: int)
signal turn_ended(player_id: int)
signal game_ended(winner_id: int, victory_type: String)
```

---

### **SaveSystem**
**Purpose**: Handle game save/load operations.

**Responsibilities**:
- Serialize game state to JSON
- Deserialize JSON to game state
- Manage save slots
- Handle version compatibility for saves

**Key Methods**:
```gdscript
func save_game(slot: int) -> Error
func load_game(slot: int) -> Error
func delete_save(slot: int) -> Error
func get_save_info(slot: int) -> Dictionary
```

---

### **DataManager**
**Purpose**: Load and manage game data resources.

**Responsibilities**:
- Load unit definitions from .tres files
- Load tile data and map configurations
- Provide data access methods
- Cache frequently accessed data

**Key Methods**:
```gdscript
func get_unit_data(unit_type: String) -> UnitData
func get_tile_data(tile_type: String) -> TileData
func load_map(map_id: String) -> MapData
```

---

### **AudioController**
**Purpose**: Manage all audio playback.

**Responsibilities**:
- Play sound effects (moves, attacks, explosions)
- Play background music
- Handle volume controls
- Manage audio buses (SFX, Music)

**Key Methods**:
```gdscript
func play_sound(sound_name: String)
func play_music(track_name: String)
func set_sfx_volume(volume: float)
func set_music_volume(volume: float)
```

---

## **SCRIPT ORGANIZATION**

### **Scene-Script Parity Principle**
Each `.tscn` file has a corresponding `.gd` file with the same name in the matching directory.

**Example**:
- `scenes/game/game_board.tscn` ←→ `scripts/game/game_board.gd`
- `scenes/ui/main_menu.tscn` ←→ `scripts/ui/main_menu.gd`

This convention makes navigation intuitive and prevents confusion.

---

### **Core Game Scripts** (`scripts/game/`)

#### **game_board.gd**
**Attached to**: `scenes/game/game_board.tscn`

**Responsibilities**:
- Coordinate all game board systems
- Manage unit instances on the board
- Handle user input (selecting units, issuing orders)
- Emit signals to UI components
- Coordinate with TurnStateMachine for state changes

**Key Signals**:
```gdscript
signal unit_selected(unit: Unit)
signal unit_deselected(unit: Unit)
signal move_order_issued(unit: Unit, target_pos: Vector2i)
signal attack_order_issued(attacker: Unit, target_pos: Vector2i)
```

---

#### **turn_state_machine.gd**
**Attached to**: `game_board.tscn` (child node)

**Responsibilities**:
- Manage turn states (Planning A → Curtain → Planning B → Resolution → End)
- Validate state transitions
- Trigger state entry/exit actions
- Maintain current turn phase

**States**:
```gdscript
enum TurnPhase {
    PLANNING_A,
    CURTAIN,
    PLANNING_B,
    RESOLUTION_MOVEMENT,
    RESOLUTION_BATTLE,
    END_TURN
}
```

---

#### **order_manager.gd**
**Attached to**: `game_board.tscn` (child node)

**Responsibilities**:
- Store movement and attack orders for current turn
- Validate orders during planning phase
- Provide order lists to resolution systems
- Clear orders at turn end

**Data Structures**:
```gdscript
class MovementOrder:
    var unit: Unit
    var source_pos: Vector2i
    var target_pos: Vector2i

class AttackOrder:
    var attacker: Unit
    var target_pos: Vector2i
    var target_unit: Unit
```

---

#### **collision_system.gd**
**Attached to**: `game_board.tscn` (child node)

**Responsibilities**:
- Detect movement collisions
- Resolve standard collisions (both units stop)
- Handle train collision exceptions
- Implement "squish rule" for trains

---

#### **battle_system.gd**
**Attached to**: `game_board.tscn` (child node)

**Responsibilities**:
- Identify all participants in each battle
- Calculate attack/defense totals
- Determine battle outcomes
- Apply damage/retreat/death
- Trigger battle scene for visual feedback

---

#### **network_system.gd**
**Attached to**: `game_board.tscn` (child node)

**Responsibilities**:
- Calculate which units are "active" (connected to source)
- Recursive raycasting for lines of effect
- Handle telegraph chain propagation
- Special case for observation balloons
- Cache active states for performance

---

#### **railway_system.gd**
**Attached to**: `game_board.tscn` (child node)

**Responsibilities**:
- Build railway graph from tile data
- Perform BFS for cascading station captures
- Validate train movement along tracks
- Handle turnarounds and intersections

---

### **Unit Scripts** (`scripts/units/`)

#### **unit.gd**
**Attached to**: `scenes/units/unit.tscn`

**Base class for all units.**

**Responsibilities**:
- Store unit properties (type, owner, position, stats)
- Handle selection/deselection
- Emit signals for game state changes
- Manage deployment/packing state (for heavy units)
- Track embark/disembark state

**Key Signals**:
```gdscript
signal selected()
signal deselected()
signal moved(from: Vector2i, to: Vector2i)
signal attacked(target: Unit)
signal health_changed(new_health: int)
signal destroyed()
```

**Properties**:
```gdscript
var unit_type: String
var owner_id: int  # 0 = Red Army, 1 = White Army
var grid_position: Vector2i
var stats: UnitStats
var is_deployed: bool = true
var carried_unit: Unit = null
var carrier_unit: Unit = null
```

---

#### **unit_behaviors/*.gd**
**Attached to**: Unit instances as child nodes

Specialized behaviors for different unit types:

- **cavalry_behavior.gd**: Cavalry charge bonus
- **train_behavior.gd**: Track movement, multi-car coordination
- **heavy_unit_behavior.gd**: Pack/deploy mechanics
- **relay_behavior.gd**: Network relay functionality

---

### **UI Scripts** (`scripts/ui/`)

Each UI scene has a corresponding script that:
- Handles UI events (button presses, selection changes)
- Emits signals to game systems
- Updates UI based on game state signals

**Example Pattern**:
```gdscript
# ui/hud/unit_info_panel.gd
extends Control

signal special_action_requested(action: String, unit: Unit)

@onready var unit_name_label: Label = $UnitName
@onready var stats_label: Label = $Stats

func _ready():
    GameManager.unit_selected.connect(_on_unit_selected)
    GameManager.unit_deselected.connect(_on_unit_deselected)

func _on_unit_selected(unit: Unit):
    unit_name_label.text = unit.unit_type
    stats_label.text = "ATK: %d | DEF: %d | MV: %d" % [
        unit.stats.attack, 
        unit.stats.defense,
        unit.stats.move
    ]
    show()

func _on_unit_deselected(unit: Unit):
    hide()
```

---

### **Utility Scripts** (`scripts/utils/`)

#### **math_helpers.gd**
Helper functions for grid math, distance calculations, etc.

#### **pathfinding.gd**
A* pathfinding for movement validation and battle participation.

#### **debug_visualizer.gd**
Tools to visualize network paths, collision detection, etc. (for development)

---

## **NAMING CONVENTIONS**

### **Scene Files (.tscn)**
- Use lowercase with underscores: `game_board.tscn`, `unit_info_panel.tscn`
- Group by functionality in subdirectories

### **Script Files (.gd)**
- Match scene file names: `game_board.tscn` → `game_board.gd`
- Use lowercase with underscores
- Class names use PascalCase: `class_name GameBoard`

### **Resource Files (.tres)**
- Use lowercase with underscores: `infantry.tres`, `map1_iron_horse.tres`
- Group by type in subdirectories

### **Variables**
- **Local variables**: snake_case: `grid_position`, `is_deployed`
- **Constants**: UPPER_SNAKE_CASE: `MAX_MOVEMENT_ORDERS = 5`
- **Private variables**: Prefix with underscore: `_internal_state`

### **Signals**
- Use past tense for completed actions: `unit_selected`, `moved`, `destroyed`
- Use noun phrases for state changes: `turn_started`, `game_ended`

---

## **SIGNAL-BASED COMMUNICATION PATTERNS**

### **Pattern 1: Child → Parent → Sibling**
```
Unit (emits "selected") 
    ↓
GameBoard (receives, emits "unit_selected")
    ↓
UnitInfoPanel (receives, updates display)
```

### **Pattern 2: UI → Game System → UI**
```
SpecialActions (emits "sabotage_requested")
    ↓
GameBoard (receives, executes sabotage, emits "tile_destroyed")
    ↓
OrderList (receives, removes order, updates display)
```

### **Pattern 3: Global Events via AutoLoad**
```
BattleSystem (emits "battle_completed")
    ↓
GameManager (receives, checks win condition, emits "game_ended")
    ↓
VictoryScreen (receives, displays result)
```

### **Benefits of Signal-Based Architecture**
- **Loose coupling**: Scenes don't need direct references to each other
- **Easy testing**: Components can be tested in isolation
- **Clear data flow**: Signals make it obvious what events occur
- **Flexibility**: Easy to add new listeners to existing signals

---

## **MODULARITY PRINCIPLES**

### **1. Single Responsibility**
Each scene/script does ONE thing:
- `unit.tscn` only handles a single unit
- `battle_scene.tscn` only handles battle visualization
- `turn_state_machine.gd` only manages turn states

### **2. Don't Break Encapsulation**
- **Parents never dig into child internals**: Use signals/methods instead
- **Siblings never communicate directly**: Route through parent or AutoLoad
- **Use public methods for controlled access**: Don't access `_private` variables

### **3. Composition Over Inheritance**
- Add behavior components as child nodes rather than deep inheritance
- Example: Attach `cavalry_behavior.gd` to a unit instance instead of making `CavalryUnit` class

### **4. Dependency Injection**
- Pass dependencies via constructor or `init()` method
- Don't hard-code AutoLoad references in unit-level scripts

---

## **SCENE INSTANTIATION PATTERNS**

### **Units**
```gdscript
# In game_board.gd
func spawn_unit(unit_type: String, owner_id: int, pos: Vector2i) -> Unit:
    var unit_scene: PackedScene = load("res://scenes/units/unit.tscn")
    var unit: Unit = unit_scene.instantiate()
    unit.initialize(unit_type, owner_id, pos)
    units_container.add_child(unit)
    return unit
```

### **UI Overlays**
```gdscript
# In game_board.gd
func show_battle_scene(battle_data: BattleData):
    var battle_scene: PackedScene = load("res://scenes/game/battle_scene.tscn")
    var battle: BattleScene = battle_scene.instantiate()
    battle.set_battle_data(battle_data)
    add_child(battle)
    battle.battle_finished.connect(_on_battle_finished)
```

---

## **GODOT 4 SPECIFIC CONSIDERATIONS**

### **TileMapLayer vs. TileMap**
- Use `TileMapLayer` (Godot 4.x) instead of `TileMap` (Godot 3.x)
- Create separate layers for:
  - Base terrain (grass, snow)
  - Obstacles (mountains, city blocks)
  - Infrastructure (rails, roads, telegraph lines)
  - Buildings (stations, telegraph offices)

### **New Signal Syntax**
```gdscript
# Godot 3.x
connect("pressed", self, "_on_button_pressed")

# Godot 4.x (preferred)
button.pressed.connect(_on_button_pressed)
```

### **Resource Type System**
- Use `.tres` files with custom resource classes for game data
- Create typed resources: `class_name UnitData extends Resource`

### **Scene Tree References**
```gdscript
# Godot 3.x
var label = get_node("VBoxContainer/Label")

# Godot 4.x (use @onready)
@onready var label: Label = $VBoxContainer/Label
```

---

## **BEST PRACTICES CHECKLIST**

### **Before Creating a New Scene:**
- [ ] Does this scene have a single, clear responsibility?
- [ ] Can I reuse existing scenes instead?
- [ ] Will this scene communicate via signals?
- [ ] Is the location in the directory structure appropriate?

### **Before Creating a New Script:**
- [ ] Does the scene actually need a script? (Some can be pure data)
- [ ] Does this script follow the naming conventions?
- [ ] Am I breaking encapsulation? (Should use signals instead)
- [ ] Can this logic be moved to an existing system?

### **Before Adding a Signal:**
- [ ] Is this signal needed? (Can I use a method call instead?)
- [ ] Is the signal name clear and descriptive?
- [ ] Will multiple listeners need this signal?
- [ ] Is the signal emitted at the right time?

### **Before Using an AutoLoad:**
- [ ] Does this need to be globally accessible?
- [ ] Is there a better way to pass this dependency?
- [ ] Am I creating too much coupling to global state?

---

## **MOBILE/PC COMPATIBILITY**

### **Scene Structure**
- All UI scenes use `Control` nodes (not `Node2D`) for automatic scaling
- Use `Control.size_flags_stretch_ratio` for responsive layouts
- Test on different screen sizes (phone, tablet, desktop)

### **Input Handling**
- Abstract input handling through signals, not direct input processing
- Use `InputEvent` handling in UI scripts
- Support both mouse and touch events

### **Performance**
- Keep node counts reasonable (avoid thousands of nodes)
- Use `queue_free()` properly for scene cleanup
- Cache frequently accessed data (unit definitions, tile data)

---

**Last Updated**: January 2, 2026
**Version**: 1.0
